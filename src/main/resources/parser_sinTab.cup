package main.java;
import java_cup.runtime.*;
import java.io.BufferedWriter;
import java.io.IOException;

parser code {:
    private LexerCupV lex;private HashMap<String, ArrayList<String>> tablaDeSimbolos = new HashMap<>();
    private BufferedWriter errorOutputFile;
    private BufferedWriter symTableOutFile;
    public Parser(LexerCupV lexer, BufferedWriter output, BufferedWriter symTableOut) {
        this.lex = lexer;
        this.errorOutputFile = output;
        this.symTableOutFile = symTableOut;
    }



    @Override
        public void report_error(String message, Object info) {
                    // al sobreescribir este método, lo que conseguimos es que el syntax_error del Parser llame este que estamos
                    // escribiendo y no el que existe por defecto
                    String error = "Error encontrado: " + message;
                    if (info instanceof Symbol) {
                        Symbol symbol = (Symbol) info;
                        error += " en la línea: " + (symbol.left) + ", columna: " + (symbol.right);
                        // se les suma uno porque se almacena iniciando en 0, pero en los archivos siempre lo leemos de 1 en adelante
                    }
                try {
                    this.errorOutputFile.write(error);
                    this.errorOutputFile.newLine();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
                // System.err.println(error);
                }
:};

scan with {:
    Symbol token = lex.next_token();
    System.out.println("Parseando token: " + token.sym + " (" + (token.sym >=0 ? sym.terminalNames[token.sym]: "ERROR") + ")");
    return token;
:};


// Tokens
terminal MAIN, INTEGER, FLOAT, BOOL, CHAR, STRING;
terminal LITERAL_INT, LITERAL_FLOAT, LITERAL_BOOL, LITERAL_CHAR, LITERAL_STRING;
terminal OPEN_BLOCK, CLOSE_BLOCK, END_EXPRESSION, SEPARATOR;
terminal OPEN_BRACKET, CLOSE_BRACKET, OPEN_PARENTHESIS, CLOSE_PARENTHESIS;
terminal ASSIGN, ADD, SUBSTRACTION, MULTIPLICATION, DIVISION, MODULO, POWER, INCREMENT, DECREMENT;
terminal LESSER, LESSER_EQUAL, GREATER, GREATER_EQUAL, EQUALS, DIFFERENT;
terminal CONJUNCTION, DISJUNCTION, NEGATION;
terminal IF, ELSE, WHILE, FOR, SWITCH, CASE, DEFAULT, BREAK, RETURN, COLON;
terminal PRINT, READ, IDENTIFIER;

// Non-terminals
non terminal program;
non terminal array_declaration;
non terminal param_declaration, func_name,func_parameters, arguments, evaluable, sec_arguments;
non terminal type, literal, func_call, unary_operator;
non terminal variable_secuence, print, read, update;
non terminal array_assignment, index_assigment, assign_variable, assignments ;
non terminal declaration, relational_operator, comparison, logical_operator;
non terminal if_expr, log_arith_expression;
non terminal cases, switch_expressions, unary_operation, arith_operator, else_expr, optional_else , block, blocks, func_declaration;
non terminal func, functions,function_end, simple_operation, simple_expressions ;
non terminal while_expressions, for_expressions, initialization;



// Precedence (como vimos en clase, entre más abajo, mayor precedencia tienen)
precedence left CONJUNCTION, DISJUNCTION;
precedence left EQUALS, DIFFERENT;
precedence left LESSER, LESSER_EQUAL, GREATER, GREATER_EQUAL;
precedence left ADD, SUBSTRACTION;
precedence left MULTIPLICATION, DIVISION, MODULO;
precedence right POWER;
precedence right INCREMENT, DECREMENT;
precedence right NEGATION;
start with program;


// Reglas de gramática
type ::= INTEGER    {: RESULT = "INT"; :}
    | FLOAT         {: RESULT = "FLOAT"; :}
    | BOOL          {: RESULT = "BOOL"; :}
    | CHAR          {: RESULT = "CHAR"; :}
    | STRING        {: RESULT = "STRING";:};


literal ::= LITERAL_INT:intLit {:RESULT = intLit; :}
| LITERAL_FLOAT:fltlit {: RESULT = fltlit; :}
| LITERAL_BOOL:boolLit {:RESULT = boolLit;:}
| LITERAL_CHAR:chrLit {:RESULT = chrLit; :}
| LITERAL_STRING:strLit {:RESULT = strLit;:};

// funciones y llamados
func_name ::= MAIN {:
        //TODO: esto debe ir en la declaración de la función porque si no, al llamar una función va a cambiar el scope
        this.currentHash = "_main_";
        System.out.println("Tabla de símbolos actual: _main_");
        reportParsedToken("******* Tabla de Simbolos cambiada a _main_ *******"); // nuestra función propia para escribir en el archivo
         RESULT = "_main_";:}

    | IDENTIFIER:idFunc {:
        this.currentHash = idFunc.toString();
        System.out.println("Tabla de símbolos actual: " + currentHash);
        RESULT = idFunc.toString();:};
func_call ::= func_name:f OPEN_PARENTHESIS arguments:arg CLOSE_PARENTHESIS
    {:System.out.println("Llamado de función: " + f.toString() + ", argumentos: " + arg.toString());
    RESULT = f + arg.toString();:};

// funciones para imprimir y leer (predeterminadas)
read ::= READ OPEN_PARENTHESIS variable_secuence CLOSE_PARENTHESIS;
print ::= PRINT OPEN_PARENTHESIS arguments CLOSE_PARENTHESIS;

// argumentos es para cuando se llama la función
arguments ::= sec_arguments:seq {:RESULT = seq;:}
            | {: RESULT = "EMPTY_ARGS"; :};
 // los argumentos pueden ser muchos, uno, o ninguno secuence op
evaluable ::= IDENTIFIER:id{:System.out.println("Argumento: Identificador: " + id);RESULT = id.toString();:}
              | literal:lit{:System.out.println("Argumento: Literal, valor:  " + lit);RESULT = lit;:}
              | func_call:call{:System.out.println("Argumento: Llamada a función: " + call);RESULT = call;:}; // les pusimos evaluable porque los 3 posibles evalúan a algo
sec_arguments ::= evaluable:ev SEPARATOR sec_arguments:seq
        {:RESULT = ev + ", " + seq;:}
    | evaluable:ev; // creo que no hace falta ponerle el result porque ya todos los evaluables tienen

// parámetros es para cuando se declara en vez de llamarse porque también deben llevar el tipo
param_declaration ::= type:t IDENTIFIER:idVar SEPARATOR param_declaration:par
            {:
            RESULT = idVar + ":" + t + ", " + par;:}
        | type:t IDENTIFIER:parId
            {:System.out.println("parámetro tipado: " + parId.toString() + " tipo:" + t);
            RESULT = parId + ":" + t;:};
func_parameters ::= param_declaration:parDec {:RESULT = parDec;:}
                  | {: RESULT = "NO_PARAMS"; :};
 // los parámetros al declarar la función también pueden ser 0 o sea ()

func_declaration ::= func_name:funcId OPEN_PARENTHESIS func_parameters:params CLOSE_PARENTHESIS OPEN_BLOCK blocks CLOSE_BLOCK
        {:RESULT = "nombre: " + funcId + ", parámetros: " + params;:};
func ::= type:t func_declaration:fDec //TODO: según yo es aquí cuando se mete la tabla
        {:System.out.println("Declaración de función: " + fDec + ", valor de retorno: " + t);:};

functions ::= func | func functions;

function_end ::= RETURN:ret evaluable:ev {:System.out.println("llamada a retorno de: " + ev.toString());:} | RETURN:ret {:System.out.println("llamada a retorno vacía.");:};

variable_secuence ::= IDENTIFIER SEPARATOR variable_secuence | IDENTIFIER; //sec_var

// operadores y operaciones
arith_operator ::= ADD {:System.out.println("Operador: SUMA"); RESULT = "+";:}
                   | SUBSTRACTION {: System.out.println("Operador: RESTA"); RESULT = "-"; :}
                   | MULTIPLICATION {:System.out.println("Operador: MULTIPLICACIÓN"); RESULT = "*";:}
                   | DIVISION {:System.out.println("Operador: DIVISIÓN");RESULT = "/";:}
                   | MODULO{:System.out.println("Operador: MÓDULO");RESULT = "%";:}
                   | POWER{:System.out.println("Operador: POTENCIA");RESULT = "^";:};


unary_operator ::= INCREMENT {:System.out.println("Operador unario: INCREMENTO");RESULT = "++";:}
                   | DECREMENT{:System.out.println("Operador unario: Decremento");RESULT = "--";:};
logical_operator ::= CONJUNCTION {:RESULT = "AND";:} | DISJUNCTION {:RESULT = "OR";:};
relational_operator ::= LESSER_EQUAL {:RESULT = "<=";:}| GREATER_EQUAL {:RESULT = ">=";:}
        | LESSER {:RESULT = "<";:} | GREATER {:RESULT = ">";:} | EQUALS {:RESULT = "==";:}
        | DIFFERENT {:RESULT = "!=";:};


// expresiones/operaciones
unary_operation ::= IDENTIFIER:id unary_operator:uOp
        {:System.out.println("Operacion unaria: " + id + uOp);
        RESULT = id.toString() + uOp;:};
log_arith_expression ::= NEGATION:not log_arith_expression:lalgexp
        {:RESULT = "NOT " + lalgexp.toString();:}
    | log_arith_expression:expr1 logical_operator:logOper log_arith_expression:expr2
        {:RESULT = expr1.toString() + logOper + expr2.toString();:}
    | comparison:cmp
        {:RESULT = cmp;:}
    | OPEN_PARENTHESIS log_arith_expression:exp CLOSE_PARENTHESIS
        {:RESULT = exp.toString();:}; // esta última es la importante para cuando hay paréntesis entre operaciones

comparison ::= log_arith_expression:expr1 relational_operator:relOper log_arith_expression:expr2
               {:RESULT = expr1.toString() + " " + relOper + " " + expr2.toString();:}
    | unary_operation:uniOp
        {:RESULT = uniOp;:}
    | evaluable:ev
        {:RESULT = ev;:}
    | log_arith_expression:expr1 arith_operator:arithOper log_arith_expression:expr2
        {:RESULT = expr1.toString() +  " " + arithOper + expr2.toString();:};

// operaciones de acceso y asignación
// TODO: meter al grupo de cosas que reportan título
update ::= ASSIGN | arith_operator ASSIGN; // cuando algo se actualiza con un operador, e.g. +=, *=, -=

array_assignment ::= IDENTIFIER:id ASSIGN OPEN_BLOCK arguments:args CLOSE_BLOCK
    {:System.out.println("Asignación a un arreglo: " + id);
    RESULT = id + " = [" + args + "]";
    agregarSimbolo("array_assignment", id.toString(), args.toString());:}; // se usa al asignar a un espacio que puede ser una llamada a funcion
index_assigment ::= IDENTIFIER:id OPEN_BRACKET evaluable:ev CLOSE_BRACKET update:op log_arith_expression:expr
    {:System.out.println("Asignación por índice: " + id + "[" + ev + "] " + op + " "+ expr.toString());
        RESULT = id + "[" + ev + "] " + op + " " + expr;
        agregarSimbolo("asignacion_indice", id.toString(), expr.toString());:};
assign_variable ::= IDENTIFIER:id update:upd log_arith_expression:expr
    {:System.out.println("Asignación de variable: " + id + " " + upd + " " + expr);
        RESULT = id + " " + upd + " " + expr.toString();
        agregarSimbolo("asignacion_variable", id.toString(), expr.toString());:}; // para cuando se asigna con un paréntesis en la expresión todo corregir
assignments ::= index_assigment | assign_variable | array_assignment ; //diferentes posibles asignaciones para tomarlas como una expresión
array_declaration ::= ASSIGN OPEN_BLOCK sec_arguments CLOSE_BLOCK
                    | {: RESULT = "EMPTY_ARRAY"; :};

declaration ::= type:tipo IDENTIFIER:id
        {:System.out.println("Declaración de variable: " + tipo + " " + id);
        RESULT = tipo + " " + id;:}
    | type:tipo IDENTIFIER:id ASSIGN log_arith_expression:expr
        {:System.out.println("Declaración con asignación: " + tipo + " " + id + " = " + expr.toString());
        RESULT = tipo + " " + id + " = " + expr;:}
    | type:tipo IDENTIFIER:id OPEN_BRACKET evaluable:ev CLOSE_BRACKET array_declaration:arr_decl
        {:System.out.println("Declaración de arreglo: " + tipo + " " + id + "[" + ev + "] " + arr_decl);
        RESULT = tipo + " " + id + "[" + ev + "] " + arr_decl;:};




// condicionales y estructuras de control
if_expr ::= IF OPEN_PARENTHESIS log_arith_expression CLOSE_PARENTHESIS OPEN_BLOCK blocks CLOSE_BLOCK optional_else;
else_expr ::= ELSE OPEN_BLOCK blocks CLOSE_BLOCK;
optional_else ::= else_expr
                | {: RESULT = "NO_ELSE"; :};
cases ::= CASE literal COLON blocks cases
        | DEFAULT COLON blocks
        | {: RESULT = "NO_CASES"; :};
switch_expressions ::= SWITCH OPEN_PARENTHESIS evaluable CLOSE_PARENTHESIS OPEN_BLOCK cases CLOSE_BLOCK;




block ::= if_expr
        | while_expressions
        | for_expressions
        | simple_expressions END_EXPRESSION
        | switch_expressions
        | error END_EXPRESSION {: System.out.println("Error recuperado en bloque."); RESULT = "ERROR_BLOCK"; :};
 // Creo que sí debe permitir bloques vacíos
blocks ::= block blocks
         | {: RESULT = "EMPTY_BLOCKS"; :};





initialization ::= assign_variable | IDENTIFIER ;

simple_operation ::= unary_operation | declaration;
simple_expressions ::= unary_operation | declaration | assignments | read | print | BREAK | func_call | function_end;
while_expressions ::= WHILE OPEN_PARENTHESIS log_arith_expression CLOSE_PARENTHESIS OPEN_BLOCK blocks CLOSE_BLOCK;
for_expressions ::= FOR OPEN_PARENTHESIS initialization SEPARATOR log_arith_expression SEPARATOR simple_operation CLOSE_PARENTHESIS OPEN_BLOCK blocks CLOSE_BLOCK;

program ::= functions {: System.out.println("Se parseó un archivo fuente."); :}
         | {: System.out.println("Archivo fuente vacío."); RESULT = "EMPTY_PROGRAM"; :};
