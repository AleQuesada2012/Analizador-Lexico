package main.java;
import java_cup.runtime.*;
import java.io.BufferedWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;

parser code {:
    private LexerCupV lex;
    private HashMap<String, ArrayList<String>> tablaDeSimbolos = new HashMap<>();
    private BufferedWriter outputFile;
    public Parser(LexerCupV lexer, BufferedWriter output) {
        this.lex = lexer;
        this.outputFile = output;
    }


    public HashMap<String, ArrayList<String>> getSymbolTable() {
        return tablaDeSimbolos;
    }


    private void agregarSimbolo(String nombre, String tipo) {
        // Agregar a la tabla de símbolos
        if (!tablaDeSimbolos.containsKey(nombre)) {
            ArrayList<String> atributos = new ArrayList<>();
            atributos.add(tipo);
            tablaDeSimbolos.put(nombre, atributos);
        } else {
            System.err.println("Error: El identificador '" + nombre + "' ya está declarado.");
        }
    }


    @Override
        public void report_error(String message, Object info) {
                    // al sobreescribir este método, lo que conseguimos es que el syntax_error del Parser llame este que estamos
                    // escribiendo y no el que existe por defecto
                    String error = "Error encontrado: " + message;
                    if (info instanceof Symbol) {
                        Symbol symbol = (Symbol) info;
                        error += "En la línea: " + (symbol.left + 1) + ", columna: " + (symbol.right + 1);
                        // se les suma uno porque se almacena iniciando en 0, pero en los archivos siempre lo leemos de 1 en adelante
                    }
                try {
                    this.outputFile.write(error);
                    this.outputFile.newLine();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
                // System.err.println(error);
                }
:};

scan with {:
    Symbol token = lex.next_token();
    System.out.println("Parseando token: " + token.sym + " (" + (token.sym >=0 ? sym.terminalNames[token.sym]: "ERROR") + ")");
    return token;
:};


// Tokens
terminal MAIN, INTEGER, FLOAT, BOOL, CHAR, STRING;
terminal LITERAL_INT, LITERAL_FLOAT, LITERAL_BOOL, LITERAL_CHAR, LITERAL_STRING;
terminal OPEN_BLOCK, CLOSE_BLOCK, END_EXPRESSION, PARAMETERS_DIVIDER;
terminal OPEN_BRACKET, CLOSE_BRACKET, OPEN_PARENTHESIS, CLOSE_PARENTHESIS;
terminal ASSIGN, ADD, SUBSTRACTION, MULTIPLICATION, DIVISION, MODULO, POWER, INCREMENT, DECREMENT;
terminal LESSER, LESSER_EQUAL, GREATER, GREATER_EQUAL, EQUALS, DIFFERENT;
terminal CONJUNCTION, DISJUNCTION, NEGATION;
terminal IF, ELSE, WHILE, FOR, SWITCH, CASE, DEFAULT, BREAK, RETURN, COLON;
terminal PRINT, READ, IDENTIFIER;

// Non-terminals
non terminal program;
non terminal array_declaration;
non terminal param_declaration, func_name,parameters_declaration, arguments, argument, sec_arguments;
non terminal type, literal, func_call, unary_opers, index;
non terminal variable_secuence, print, variable_read, arith_expr, update;
non terminal array_assignment, index_assigment, assign_variable, assignments ;
non terminal declaration, relational_oper, comparison, logical_oper;
non terminal logical_expr, if_expr;
non terminal cases, switch_expressions, unary_operation, arithmetic_op, else_expr, optional_else , block, blocks, function_header;
non terminal func, functions,function_end, simple_operation, simple_expressions ;
non terminal while_expressions, for_expressions, for_undeclared;



// Precedence (como vimos en clase, entre más abajo, mayor precedencia tienen)
precedence left CONJUNCTION, DISJUNCTION;
precedence left EQUALS, DIFFERENT;
precedence left LESSER, LESSER_EQUAL, GREATER, GREATER_EQUAL;
precedence left ADD, SUBSTRACTION;
precedence left MULTIPLICATION, DIVISION, MODULO;
precedence right POWER;
precedence right INCREMENT, DECREMENT;
precedence right NEGATION;
start with program;


// Reglas de gramática
//TODO: el for no está aceptando cuando se usa un identificador que ya fue declarado, la asignación no está dejando paréntesis, y la llamada a miFunc en línea 51 falla


// definir cómo son los tipos, los parámetros y otros no terminales antes de empezar las reglas de gramática
param_declaration ::= type IDENTIFIER | ;
func_name ::= MAIN | IDENTIFIER;
parameters_declaration ::= parameters_declaration PARAMETERS_DIVIDER param_declaration | param_declaration; //TODO: tengo duda con esta
arguments ::= sec_arguments | ; // los argumentos pueden ser muchos, uno, o ninguno secuence op
argument ::= IDENTIFIER | literal | func_call;
sec_arguments ::= argument PARAMETERS_DIVIDER sec_arguments | argument;

func_call ::= func_name OPEN_PARENTHESIS arguments CLOSE_PARENTHESIS;


type ::= INTEGER | FLOAT | BOOL | CHAR | STRING;
literal ::= LITERAL_INT | LITERAL_FLOAT | LITERAL_BOOL | LITERAL_CHAR | LITERAL_STRING;
arithmetic_op ::= ASSIGN | ADD | SUBSTRACTION | MULTIPLICATION | DIVISION | MODULO | POWER;
unary_opers ::= INCREMENT | DECREMENT;
index ::= LITERAL_INT | IDENTIFIER;

variable_secuence ::= IDENTIFIER PARAMETERS_DIVIDER variable_secuence | IDENTIFIER; //sec_var
print ::= PRINT OPEN_PARENTHESIS arguments CLOSE_PARENTHESIS;
variable_read ::= READ OPEN_PARENTHESIS variable_secuence CLOSE_PARENTHESIS;

arith_expr ::= argument arithmetic_op argument | argument;



update ::= ASSIGN | arithmetic_op ASSIGN; // cuando algo se actualiza con un operador, e.g.
array_assignment ::= IDENTIFIER ASSIGN OPEN_BLOCK arguments CLOSE_BLOCK; // se usa al asignar a un espacio que puede ser una llamada a funcion
index_assigment ::= IDENTIFIER OPEN_BRACKET index CLOSE_BRACKET ASSIGN arith_expr;
assign_variable ::= IDENTIFIER update arith_expr;
assignments ::= assign_variable | array_assignment | index_assigment; //diferentes posibles asignaciones

array_declaration::= ASSIGN OPEN_BLOCK arguments CLOSE_BLOCK | ;

declaration ::= type IDENTIFIER {:
    String varType = ((Symbol)$1).value.toString();
    String varName = ((Symbol)$2).value.toString();
    addToSymbolTable(varName, varType);
:}
| type IDENTIFIER ASSIGN arith_expr {:
    String varType = ((Symbol)$1).value.toString();
    String varName = ((Symbol)$2).value.toString();
    addToSymbolTable(varName, varType);
:}
| type IDENTIFIER OPEN_BRACKET index CLOSE_BRACKET array_declaration {:
    String varType = ((Symbol)$1).value.toString() + "[]";
    String varName = ((Symbol)$2).value.toString();
    addToSymbolTable(varName, varType);
:};
relational_oper ::= LESSER | LESSER_EQUAL | GREATER | GREATER_EQUAL | EQUALS | DIFFERENT;
comparison ::= argument relational_oper comparison | argument; // TODO: revisar si la estructura tiene sentido
logical_oper ::= CONJUNCTION | DISJUNCTION;
logical_expr ::= NEGATION comparison logical_expr | logical_expr logical_oper logical_expr | comparison;
if_expr ::= IF OPEN_PARENTHESIS logical_expr CLOSE_PARENTHESIS OPEN_BLOCK blocks CLOSE_BLOCK optional_else;

cases::= CASE literal COLON block cases | DEFAULT COLON block;
switch_expressions ::= SWITCH OPEN_PARENTHESIS argument CLOSE_PARENTHESIS OPEN_BLOCK cases CLOSE_BLOCK;

unary_operation ::= IDENTIFIER unary_opers;
else_expr ::= ELSE OPEN_BLOCK blocks CLOSE_BLOCK;
optional_else ::= else_expr | ;

block ::= if_expr | while_expressions | for_expressions | simple_expressions END_EXPRESSION
                    | switch_expressions | error END_EXPRESSION;
blocks ::= block blocks | block;


function_header ::= func_name OPEN_PARENTHESIS parameters_declaration CLOSE_PARENTHESIS OPEN_BLOCK blocks CLOSE_BLOCK;
func ::= type function_header {:
    String funcType = ((Symbol)$1).value.toString();
    String funcName = ((Symbol)$2).value.toString();
    addToSymbolTable(funcName, funcType);
:};
functions ::= func | func functions;
