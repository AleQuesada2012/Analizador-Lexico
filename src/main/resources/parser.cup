package main.java;
import java_cup.runtime.*;
import java.io.BufferedWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;

parser code {:
    private LexerCupV lex;
    private HashMap<String, ArrayList<String>> tablaDeSimbolos = new HashMap<>();
    private BufferedWriter outputFile;
    public Parser(LexerCupV lexer, BufferedWriter output) {
        this.lex = lexer;
        this.outputFile = output;
    }


    public HashMap<String, ArrayList<String>> getSymbolTable() {
        return tablaDeSimbolos;
    }

    public void agregarSimbolo(String tipo, String nombre, String valor) {
        // Crear el símbolo en formato: nombre(valor)
        String simbolo = nombre + "(" + valor + ")";

        // Si el tipo no existe en la tabla, inicializar la lista
        if (!tablaDeSimbolos.containsKey(tipo)) {
            tablaDeSimbolos.put(tipo, new ArrayList<>());
        }

        // Agregar el símbolo a la lista correspondiente al tipo
        tablaDeSimbolos.get(tipo).add(simbolo);
    }

    // Método para imprimir la tabla de símbolos
    public void imprimirTablaDeSimbolos() {
        System.out.println("Tabla de Símbolos:");
        for (String tipo : tablaDeSimbolos.keySet()) {
            System.out.println(tipo + ":");
            for (String simbolo : tablaDeSimbolos.get(tipo)) {
                System.out.println("  - " + simbolo);
            }
        }
    }

    @Override
        public void report_error(String message, Object info) {
                    // al sobreescribir este método, lo que conseguimos es que el syntax_error del Parser llame este que estamos
                    // escribiendo y no el que existe por defecto
                    String error = "Error encontrado: " + message;
                    if (info instanceof Symbol) {
                        Symbol symbol = (Symbol) info;
                        error += "En la línea: " + (symbol.left + 1) + ", columna: " + (symbol.right + 1);
                        // se les suma uno porque se almacena iniciando en 0, pero en los archivos siempre lo leemos de 1 en adelante
                    }
                try {
                    this.outputFile.write(error);
                    this.outputFile.newLine();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
                // System.err.println(error);
                }
:};

scan with {:
    Symbol token = lex.next_token();
    System.out.println("Parseando token: " + token.sym + " (" + (token.sym >=0 ? sym.terminalNames[token.sym]: "ERROR") + ")");
    return token;
:};


// Tokens
terminal MAIN, INTEGER, FLOAT, BOOL, CHAR, STRING;
terminal LITERAL_INT, LITERAL_FLOAT, LITERAL_BOOL, LITERAL_CHAR, LITERAL_STRING;
terminal OPEN_BLOCK, CLOSE_BLOCK, END_EXPRESSION, PARAMETERS_DIVIDER;
terminal OPEN_BRACKET, CLOSE_BRACKET, OPEN_PARENTHESIS, CLOSE_PARENTHESIS;
terminal ASSIGN, ADD, SUBSTRACTION, MULTIPLICATION, DIVISION, MODULO, POWER, INCREMENT, DECREMENT;
terminal LESSER, LESSER_EQUAL, GREATER, GREATER_EQUAL, EQUALS, DIFFERENT;
terminal CONJUNCTION, DISJUNCTION, NEGATION;
terminal IF, ELSE, WHILE, FOR, SWITCH, CASE, DEFAULT, BREAK, RETURN, COLON;
terminal PRINT, READ, IDENTIFIER;

// Non-terminals
non terminal program;
non terminal array_declaration;
non terminal param_declaration, func_name,parameters_declaration, arguments, argument, sec_arguments;
non terminal type, literal, func_call, unary_opers, index;
non terminal variable_secuence, print, variable_read, arith_expr, update;
non terminal array_assignment, index_assigment, assign_variable, assignments ;
non terminal declaration, relational_oper, comparison, logical_oper;
non terminal logical_expr, if_expr;
non terminal cases, switch_expressions, unary_operation, arithmetic_op, else_expr, optional_else , block, blocks, function_header;
non terminal func, functions,function_end, simple_operation, simple_expressions ;
non terminal while_expressions, for_expressions, for_undeclared;



// Precedence (como vimos en clase, entre más abajo, mayor precedencia tienen)
precedence left CONJUNCTION, DISJUNCTION;
precedence left EQUALS, DIFFERENT;
precedence left LESSER, LESSER_EQUAL, GREATER, GREATER_EQUAL;
precedence left ADD, SUBSTRACTION;
precedence left MULTIPLICATION, DIVISION, MODULO;
precedence right POWER;
precedence right INCREMENT, DECREMENT;
precedence right NEGATION;
start with program;


// Reglas de gramática
//TODO: el for no está aceptando cuando se usa un identificador que ya fue declarado, la asignación no está dejando paréntesis, y la llamada a miFunc en línea 51 falla


// definir cómo son los tipos, los parámetros y otros no terminales antes de empezar las reglas de gramática
param_declaration ::= type: type IDENTIFIER:idVar PARAMETERS_DIVIDER declaracion_parametro {:System.out.println("Parámetro: " + idVar); RESULT = idVar.toString(); agregarSimbolo("parametro", idVar.toString(), tipo.toString());:}
| type:type IDENTIFIER:idVar {:System.out.println("Parámetro: " + idVar); RESULT = idVar.toString(); agregarSimbolo("parametro", idVar.toString(), tipo.toString());:};
func_name ::= MAIN |IDENTIFIER: idVar{:System.out.println("identificador de uncion "+ idVar); RRSULT = idVar.toString(); agregarSimbolo("funcion", idVar.toString(), "N/A");:};

parameters_declaration ::= parameters_declaration PARAMETERS_DIVIDER param_declaration | param_declaration; //TODO: tengo duda con esta
arguments ::= sec_arguments | ; // los argumentos pueden ser muchos, uno, o ninguno secuence op
argument ::= IDENTIFIER:id
    {:
        System.out.println("Argumento: Identificador " + id);
        RESULT = id.toString();
        agregarSimbolo("argumento", id.toString(), "N/A");
    :}
| literal:lit
    {:
        System.out.println("Argumento: Literal " + lit);
        RESULT = lit;
    :}
| func_call:call
    {:
        System.out.println("Argumento: Llamada a función " + call);
        RESULT = call;
    :};

unary_opers ::= INCREMENT
    {:
        System.out.println("Operador unario: Incremento");
        RESULT = "++";
    :}
| DECREMENT
    {:
        System.out.println("Operador unario: Decremento");
        RESULT = "--";
    :};

variable_secuence ::= IDENTIFIER:id PARAMETERS_DIVIDER variable_secuence:rest
    {:
        System.out.println("Secuencia de variables: " + id);
        RESULT = id + ", " + rest;
    :}
| IDENTIFIER:id
    {:
        System.out.println("Secuencia de variables: " + id);
        RESULT = id;
    :};
sec_arguments ::= argument PARAMETERS_DIVIDER sec_arguments | argument;

func_call ::= func_name OPEN_PARENTHESIS arguments CLOSE_PARENTHESIS;


type ::= INTEGER {: System.out.println("Tipo: INTEGER"); RESULT = "INTEGER"; :}
| FLOAT {: System.out.println("Tipo: FLOAT"); RESULT = "FLOAT"; :}
| BOOL{: System.out.println("Tipo: BOOL"); RESULT = "BOOL"; :}
| CHAR{: System.out.println("Tipo: CHAR"); RESULT = "CHAR"; :}
| STRING {: System.out.println("Tipo: STRING"); RESULT = "STRING";:};

literal ::= LITERAL_INT:int {:System.out.println("Literal entero: " + int); RESULT = int; :}
| LITERAL_FLOAT:flt {: System.out.println("Literal flotante: " + flt); RESULT = flt; :}
| LITERAL_BOOL:bool{:System.out.println("Literal booleano: " + bool); RESULT = bool;:}
| LITERAL_CHAR:chr {:System.out.println("Literal carácter: " + chr); RESULT = chr; :}
| LITERAL_STRING:str{:System.out.println("Literal cadena: " + str);RESULT = str;:};

arithmetic_op ::= ASSIGN {:System.out.println("Operador: ASIGNACIÓN");RESULT = "=";:}
| ADD {:System.out.println("Operador: SUMA"); RESULT = "+";:}
| SUBSTRACTION {: System.out.println("Operador: RESTA"); RESULT = "-"; :}
| MULTIPLICATION {:System.out.println("Operador: MULTIPLICACIÓN"); RESULT = "*";:}
| DIVISION {:System.out.println("Operador: DIVISIÓN");RESULT = "/";:}
| MODULO{:System.out.println("Operador: MÓDULO");RESULT = "%";:}
| POWER{:System.out.println("Operador: POTENCIA");RESULT = "^";:};

unary_opers ::= INCREMENT | DECREMENT;
index ::= LITERAL_INT | IDENTIFIER;

variable_secuence ::= IDENTIFIER PARAMETERS_DIVIDER variable_secuence | IDENTIFIER; //sec_var
print ::= PRINT OPEN_PARENTHESIS arguments CLOSE_PARENTHESIS;
variable_read ::= READ OPEN_PARENTHESIS variable_secuence CLOSE_PARENTHESIS;

arith_expr ::= argument arithmetic_op argument | argument;



update ::= ASSIGN | arithmetic_op ASSIGN; // cuando algo se actualiza con un operador, e.g.
array_assignment ::= IDENTIFIER:id ASSIGN OPEN_BLOCK arguments:args CLOSE_BLOCK
    {:System.out.println("Asignación a un arreglo: " + id);
        RESULT = id + " = [" + args + "]";
        agregarSimbolo("asignacion_arreglo", id.toString(), args);:};


index_assigment ::= IDENTIFIER:id OPEN_BRACKET index:ind CLOSE_BRACKET ASSIGN arith_expr:expr
    {:System.out.println("Asignación por índice: " + id + "[" + ind + "] = " + expr);
        RESULT = id + "[" + ind + "] = " + expr;
        agregarSimbolo("asignacion_indice", id.toString(), expr);:};

assign_variable ::= IDENTIFIER:id update:upd arith_expr:expr
    {:System.out.println("Asignación de variable: " + id + " " + upd + " " + expr);
        RESULT = id + " " + upd + " " + expr;
        agregarSimbolo("asignacion_variable", id.toString(), expr);:};
assignments ::= assign_variable | array_assignment | index_assigment; //diferentes posibles asignaciones

array_declaration::= ASSIGN OPEN_BLOCK arguments CLOSE_BLOCK | ;

declaration ::= type:tipo IDENTIFIER:id
    {:System.out.println("Declaración de variable: " + tipo + " " + id);
        RESULT = tipo + " " + id;
        agregarSimbolo("declaracion_variable", id.toString(), tipo.toString());:}


| type:tipo IDENTIFIER:id ASSIGN arith_expr:expr
    {:System.out.println("Declaración con asignación: " + tipo + " " + id + " = " + expr);
        RESULT = tipo + " " + id + " = " + expr;
        agregarSimbolo("declaracion_variable", id.toString(), tipo.toString());:}

| type:tipo IDENTIFIER:id OPEN_BRACKET index:ind CLOSE_BRACKET array_declaration:arr_decl
    {:System.out.println("Declaración de arreglo: " + tipo + " " + id + "[" + ind + "] " + arr_decl);
        RESULT = tipo + " " + id + "[" + ind + "] " + arr_decl;
        agregarSimbolo("declaracion_arreglo", id.toString(), tipo.toString());:};

relational_oper ::= LESSER | LESSER_EQUAL | GREATER | GREATER_EQUAL | EQUALS | DIFFERENT;
comparison ::= argument relational_oper comparison | argument; // TODO: revisar si la estructura tiene sentido
logical_oper ::= CONJUNCTION | DISJUNCTION;
logical_expr ::= NEGATION comparison logical_expr | logical_expr logical_oper logical_expr | comparison;
if_expr ::= IF OPEN_PARENTHESIS logical_expr CLOSE_PARENTHESIS OPEN_BLOCK blocks CLOSE_BLOCK optional_else;

cases::= CASE literal COLON block cases | DEFAULT COLON block;
switch_expressions ::= SWITCH OPEN_PARENTHESIS argument CLOSE_PARENTHESIS OPEN_BLOCK cases CLOSE_BLOCK;

unary_operation ::= IDENTIFIER unary_opers;
else_expr ::= ELSE OPEN_BLOCK blocks CLOSE_BLOCK;
optional_else ::= else_expr | ;

block ::= if_expr | while_expressions | for_expressions | simple_expressions END_EXPRESSION
                    | switch_expressions | error END_EXPRESSION;
blocks ::= block blocks | block;


function_header ::= func_name OPEN_PARENTHESIS parameters_declaration CLOSE_PARENTHESIS OPEN_BLOCK blocks CLOSE_BLOCK;
func ::= type function_header ;
functions ::= func | func functions;
